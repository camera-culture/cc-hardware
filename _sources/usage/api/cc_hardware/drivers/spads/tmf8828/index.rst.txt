
:py:mod:`cc_hardware.drivers.spads.tmf8828`
===========================================


.. py:module:: cc_hardware.drivers.spads.tmf8828

.. autoapi-nested-parse::

   TMF8828 sensor driver for SPAD sensors.

   The `TMF8828     <https://ams-osram.com/products/sensor-solutions/        direct-time-of-flight-sensors-dtof/            ams-tmf8828-configurable-8x8-multi-zone-time-of-flight-sensor>`_
   is a 8x8 multi-zone time-of-flight sensor made by AMS. It uses a wide VCSEL and supports
   custom mapping of SPAD pixels to allow for 3x3, 4x4, 3x6, and 8x8 multizone output. The
   :class:`~cc_hardware.drivers.spads.tmf8828.TMF8828Sensor` class was developed to interface with the
   `TMF882X Arduino Shield     <https://ams-osram.com/products/boards-kits-accessories/kits/        ams-tmf882x-evm-eb-shield-evaluation-kit>`_.



Module Contents
---------------

Classes
~~~~~~~

.. autoapisummary::

   cc_hardware.drivers.spads.tmf8828.SPADID
   cc_hardware.drivers.spads.tmf8828.RangeMode
   cc_hardware.drivers.spads.tmf8828.TMF8828Config
   cc_hardware.drivers.spads.tmf8828.TMF8828Data
   cc_hardware.drivers.spads.tmf8828.TMF8828Sensor




.. py:class:: SPADID(*args, **kwds)


   .. autoapi-inheritance-diagram:: cc_hardware.drivers.spads.tmf8828.SPADID
      :parts: 1


   Create a collection of name/value pairs.

   Example enumeration:

   >>> class Color(Enum):
   ...     RED = 1
   ...     BLUE = 2
   ...     GREEN = 3

   Access them by:

   - attribute access:

     >>> Color.RED
     <Color.RED: 1>

   - value lookup:

     >>> Color(1)
     <Color.RED: 1>

   - name lookup:

     >>> Color['RED']
     <Color.RED: 1>

   Enumerations can be iterated over, and know how many members they have:

   >>> len(Color)
   3

   >>> list(Color)
   [<Color.RED: 1>, <Color.BLUE: 2>, <Color.GREEN: 3>]

   Methods can be added to enumerations, and members can have their own
   attributes -- see the documentation for details.


   .. py:property:: num_channels
      :type: int

      Returns the number of channels based on the SPAD ID.

      :returns: *int* -- The number of channels corresponding to the SPAD ID.


   .. py:property:: active_channels_per_subcapture
      :type: list[int]

      Returns the number of active channels per subcapture based on the SPAD ID.

      :returns: *list[int]* --

                A list representing the number of active channels in each
                    subcapture.


   .. py:property:: resolution
      :type: tuple[int, int]

      Returns the resolution of the sensor based on the SPAD ID.

      :returns: *tuple[int, int]* -- The resolution (width, height) corresponding to the SPAD ID.


   .. py:property:: fov
      :type: tuple[float, float]

      Returns the field of view (FOV) in degrees based on the SPAD ID.

      :returns: *tuple[float, float]* --

                The field of view (FOVx, FOVy) corresponding to the
                    SPAD ID.


   .. py:method:: __repr__()

      Return repr(self).



   .. py:method:: __str__()

      Return str(self).



   .. py:method:: __dir__()

      Returns public methods and other interesting attributes.



   .. py:method:: __format__(format_spec)

      Default object formatter.

      Return str(self) if format_spec is empty. Raise TypeError otherwise.



   .. py:method:: __hash__()

      Return hash(self).



   .. py:method:: __reduce_ex__(proto)

      Helper for pickle.



   .. py:method:: name()

      The name of the Enum member.



   .. py:method:: value()

      The value of the Enum member.



.. py:class:: RangeMode(*args, **kwds)


   .. autoapi-inheritance-diagram:: cc_hardware.drivers.spads.tmf8828.RangeMode
      :parts: 1


   Create a collection of name/value pairs.

   Example enumeration:

   >>> class Color(Enum):
   ...     RED = 1
   ...     BLUE = 2
   ...     GREEN = 3

   Access them by:

   - attribute access:

     >>> Color.RED
     <Color.RED: 1>

   - value lookup:

     >>> Color(1)
     <Color.RED: 1>

   - name lookup:

     >>> Color['RED']
     <Color.RED: 1>

   Enumerations can be iterated over, and know how many members they have:

   >>> len(Color)
   3

   >>> list(Color)
   [<Color.RED: 1>, <Color.BLUE: 2>, <Color.GREEN: 3>]

   Methods can be added to enumerations, and members can have their own
   attributes -- see the documentation for details.


   .. py:property:: timing_resolution
      :type: float

      Returns the timing resolution for the range mode.

      :returns: *float* -- The timing resolution in seconds.


   .. py:method:: __repr__()

      Return repr(self).



   .. py:method:: __str__()

      Return str(self).



   .. py:method:: __dir__()

      Returns public methods and other interesting attributes.



   .. py:method:: __format__(format_spec)

      Default object formatter.

      Return str(self) if format_spec is empty. Raise TypeError otherwise.



   .. py:method:: __hash__()

      Return hash(self).



   .. py:method:: __reduce_ex__(proto)

      Helper for pickle.



   .. py:method:: name()

      The name of the Enum member.



   .. py:method:: value()

      The value of the Enum member.



.. py:class:: TMF8828Config


   .. autoapi-inheritance-diagram:: cc_hardware.drivers.spads.tmf8828.TMF8828Config
      :parts: 1


   Configuration for the TMF8828 sensor.

   :ivar port: The port to use for communication with the sensor.

   :vartype port: str | None
   :ivar spad_id: The SPAD ID indicating the resolution of the sensor.
   :vartype spad_id: SPADID
   :ivar range_mode: The range mode for the sensor (LONG or SHORT).

   :vartype range_mode: RangeMode


   .. py:property:: num_pixels
      :type: int

      Returns the total number of pixels in the sensor.


   .. py:property:: settings
      :type: dict[str, cc_hardware.utils.setting.Setting]

      Retrieves the sensor settings.


   .. py:attribute:: config
      :type: Optional[omegaconf.DictConfig]

      The original, uninstantiated config. This is maintained within each nested
      instantiated config to allow for proper serialization and deserialization, as well
      as printing the config as a yaml string.


   .. py:attribute:: custom
      :type: Optional[Dict[str, Any]]

      Custom data to use. This is useful for code-specific logic (i.e. not in yaml
      files) where you want to store data that is not necessarily defined in the config.


   .. py:method:: instantiate(config, *, _convert_ = 'object', **kwargs)
      :classmethod:


      Instantiate the config into an object.

      :Parameters: **config** (*DictConfig | ListConfig*) -- The config to instantiate.

      :keyword _convert_: The conversion method to use. Defaults to "object", meaning
                          all structured configs will be converted to their dataclass equivalent.
      :kwtype _convert_: str
      :keyword \*\*kwargs: Additional keyword arguments to pass to the instantiation method.



   .. py:method:: compose(config_dir, config_name, *, overrides = [], return_hydra_config = False, **kwargs)
      :classmethod:


      Compose a config using the Hydra compose API. This will return the config as
      a HydraContainerConfig instance.

      :Parameters: * **config_dir** (*Path | str*) -- The path to the config directory.
                   * **config_name** (*str*) -- The name of the config file.

      :keyword overrides: The overrides to use when composing the config.
      :kwtype overrides: List[str]
      :keyword return_hydra_config: Whether to return the HydraConfig object.
      :kwtype return_hydra_config: bool
      :keyword \*\*kwargs: Additional keyword arguments to pass to the instantiation method.



   .. py:method:: load(*args, instantiate = True, pattern = None, **instantiate_kwargs)
      :classmethod:


      Wrapper around OmegaConf.load to instantiate the config.

      :keyword instantiate: Whether to instantiate the config into an object.
      :kwtype instantiate: bool
      :keyword pattern: The specific pattern to select from the loaded
                        config.
      :kwtype pattern: Optional[str]
      :keyword \*\*instantiate_kwargs: Additional keyword arguments to pass to the
                                       instantiation method.



   .. py:method:: create(*args, instantiate = True, instantiate_kwargs = {}, **kwargs)
      :classmethod:


      Wrapper around OmegaConf.create to instantiate the config.

      :keyword instantiate: Whether to instantiate the config into an object.
      :kwtype instantiate: bool
      :keyword \*\*instantiate_kwargs: Additional keyword arguments to pass to the
                                       instantiation method.



   .. py:method:: merge_with(*others)

      Wrapper around OmegaConf.merge to merge the config with another config.

      :Parameters: **others** (*DictConfig | ListConfig | Dict | List*) -- The other config(s) to
                   merge with.



   .. py:method:: copy()

      Wrapper around the copy method to return a new instance of this class.

      .. note::

         This method will perform a deepcopy, meaning the :meth:`__getstate__` and
         :meth:`__setstate__` methods will be called. This is fairly slow since
         the object is pickled and unpickled.



   .. py:method:: save(path, *, header = None)

      Saves the config to a yaml file.

      :Parameters: **path** (*Path | str*) -- The path to save the config to.

      :keyword header: The header to add to the top of the yaml file.
      :kwtype header: str



   .. py:method:: to_yaml()

      Wrapper around OmegaConf.to_yaml to convert the config to a yaml string.
      Adds some custom representers.

      This uses the stored config attribute to convert to yaml. If the config is None,
      this will return the default string representation of the object.



   .. py:method:: __getstate__()

      This is used to pickle the object. We'll return the config as the state.



   .. py:method:: __setstate__(state)

      This is used to unpickle the object. We'll set the config from the state.



   .. py:method:: __str__()

      Convert the config to a yaml string.



   .. py:method:: register(class_type)
                  register(class_name: str, module_path: str) -> None
                  register(class_name: str, module_path: str, friend: str) -> None
      :classmethod:


      Registers a class in this registry.

      :Parameters: * **class_type** (*type[Self] | str*) -- A class object or a class name for lazy
                     loading.
                   * **module_path** (*str | None*) -- Path to the module if `class_type` is a string.
                   * **friend** (*str | None*) -- Name of another class to associate with this class.

      :returns: *type[Self] | None* --

                The registered class if `class_type` is a type,
                    otherwise None.



   .. py:method:: create_from_registry(name = None, *args, **kwargs)
      :classmethod:


      Creates an instance of a registered class, performing lazy loading if necessary.

      :Parameters: * **name** (*str | None*) -- The name of the class to instantiate. If None,
                     and only one class is registered, it will instantiate that class.
                   * **\*args** (*Any*) -- Positional arguments to pass to the class constructor.
                   * **\*\*kwargs** (*Any*) -- Keyword arguments to pass to the class constructor.

      :returns: *Self | Any* --

                An instance of the requested class, or an associated
                    'friend' class.



   .. py:method:: registry()

      Get the registry for this class.

      :returns: A dictionary mapping class names to class objects or lazy load paths.



   .. py:method:: registered()

      Get an enumeration of the registered classes.

      :returns: An enumeration of the registered classes.



.. py:class:: TMF8828Data(config)


   .. autoapi-inheritance-diagram:: cc_hardware.drivers.spads.tmf8828.TMF8828Data
      :parts: 1


   Processes and stores both histogram and target data from the VL53L8CH sensor.

   This class handles the accumulation and processing of histogram bins
   and per-pixel target information, keeping them aligned by pixel index.


   .. py:method:: reset()

      Resets the sensor data to its initial state.



   .. py:method:: process(row)

      Processes a row of data, routing to histogram or target handlers.

      :Parameters: **row** (*list[str]*) -- A row of string values from sensor output.

      :returns: *bool* -- True if processing succeeds, False otherwise.



   .. py:property:: has_data
      :type: bool

      Checks if the sensor has data available.


   .. py:method:: get_data(*, verify_has_data = True, reset = True)

      Retrieves the processed sensor data.



   .. py:method:: calculate_point_cloud(*, histogram = None, distances = None, subpixel_samples = 1, bilinear_interpolation = False)

      Calculates the point cloud from histogram or precomputed distances.

      :Parameters: * **histogram** (*np.ndarray*) -- Histogram data, if distances not provided.
                   * **distances** (*np.ndarray*) -- Precomputed distances (mm).

      :keyword subpixel_samples: Number of samples per pixel.
      :kwtype subpixel_samples: int
      :keyword bilinear_interpolation: Whether to interpolate distances.
      :kwtype bilinear_interpolation: bool

      :returns: *np.ndarray* -- Point cloud (N, 3) in meters.



   .. py:method:: calculate_distance(histogram, *, window = 10, threshold = 0)

      Calculates the distance from the histogram data.

      :Parameters: **histogram** (*np.ndarray*) -- The histogram data.

      :keyword window: The size of the window to use for distance calculation.
                       Defaults to 10.
      :kwtype window: int

      :returns: *np.ndarray* -- The calculated distance.



.. py:class:: TMF8828Sensor(config)


   .. autoapi-inheritance-diagram:: cc_hardware.drivers.spads.tmf8828.TMF8828Sensor
      :parts: 1


   A class representing the TMF8828 sensor, a specific implementation of a SPAD sensor.
   The TMF8828 sensor collects histogram data across multiple channels and subcaptures,
   enabling high-resolution depth measurements.

   Inherits:
       SPADSensor: Base class for SPAD sensors that defines common methods and
           properties.

   :ivar SCRIPT: The default path to the sensor's Arduino script.
   :vartype SCRIPT: Path
   :ivar BAUDRATE: The communication baud rate.
   :vartype BAUDRATE: int
   :ivar TIMEOUT: The timeout value for sensor communications.

   :vartype TIMEOUT: float


   .. py:property:: config
      :type: TMF8828Config

      Returns the configuration for the sensor.

      :returns: *TMF8828Config* -- The configuration for the sensor.


   .. py:method:: accumulate(num_samples = 1)

      Accumulates histogram samples from the sensor.

      :Parameters: * **num_samples** (*int*) -- The number of samples to accumulate.
                   * **average** (*bool*) -- Whether to average the accumulated samples. Defaults to
                     True.

      :returns: *np.ndarray | list[np.ndarray]* --

                The accumulated histogram data, averaged if
                    requested.



   .. py:method:: calibrate(configurations = 2)

      Performs calibration on the sensor. This will run calibration for each
      configuration.

      :Parameters: **configurations** (*int*) -- The number of configurations to calibrate. Defaults
                   to 2.

      :returns: *list[str]* -- A list containing the calibration strings for different modes.



   .. py:property:: is_okay
      :type: bool

      Checks if the sensor is operational.

      :returns: *bool* -- True if the sensor is operational, False otherwise.


   .. py:method:: close()

      Closes the sensor connection and stops background processes.



   .. py:property:: num_bins
      :type: int

      Returns the number of bins in the sensor's histogram. This indicates the
      number of discrete values or ranges that the sensor can measure. The total
      distance a sensor can measure is equal to the number of bins multiplied by
      the bin width.

      :returns: *int* -- The total number of bins in the histogram.


   .. py:property:: resolution
      :type: tuple[int, int]

      Returns the resolution of the sensor as a tuple (width, height). This indicates
      the spatial resolution of the sensor, where the width and height refer to the
      number of pixels or sampling points in the respective dimensions.

      :returns: *tuple[int, int]* --

                A tuple representing the sensor's resolution
                    (width, height).


   .. py:property:: settings
      :type: dict[str, cc_hardware.utils.setting.Setting]

      Retrieves the sensor settings.


   .. py:method:: update(**kwargs)

      Updates the sensor configuration with provided keyword arguments. If there are
      any changes given via the kwargs or in the settings, the configuration is sent
      to the sensor.

      :Parameters: **\*\*kwargs** -- Configuration parameters to update. Keys must match
                   the fields of SensorConfig.

      :returns: *bool* -- True if the configuration was updated. False if no changes were made.



   .. py:method:: __del__()

      Destructor to ensure the sensor is properly closed.



   .. py:method:: create_from_config(config, **kwargs)
      :classmethod:


      Create an instance of the class from a configuration object.

      :Parameters: **config** (*T*) -- The configuration object.

      :returns: *Self* -- An instance of the class.



   .. py:method:: register(class_type)
                  register(class_name: str, module_path: str) -> None
                  register(class_name: str, module_path: str, friend: str) -> None
      :classmethod:


      Registers a class in this registry.

      :Parameters: * **class_type** (*type[Self] | str*) -- A class object or a class name for lazy
                     loading.
                   * **module_path** (*str | None*) -- Path to the module if `class_type` is a string.
                   * **friend** (*str | None*) -- Name of another class to associate with this class.

      :returns: *type[Self] | None* --

                The registered class if `class_type` is a type,
                    otherwise None.



   .. py:method:: create_from_registry(name = None, *args, **kwargs)
      :classmethod:


      Creates an instance of a registered class, performing lazy loading if necessary.

      :Parameters: * **name** (*str | None*) -- The name of the class to instantiate. If None,
                     and only one class is registered, it will instantiate that class.
                   * **\*args** (*Any*) -- Positional arguments to pass to the class constructor.
                   * **\*\*kwargs** (*Any*) -- Keyword arguments to pass to the class constructor.

      :returns: *Self | Any* --

                An instance of the requested class, or an associated
                    'friend' class.



   .. py:method:: registry()

      Get the registry for this class.

      :returns: A dictionary mapping class names to class objects or lazy load paths.



   .. py:method:: registered()

      Get an enumeration of the registered classes.

      :returns: An enumeration of the registered classes.



