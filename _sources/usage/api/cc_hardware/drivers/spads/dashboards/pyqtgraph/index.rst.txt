
:py:mod:`cc_hardware.drivers.spads.dashboards.pyqtgraph`
========================================================


.. py:module:: cc_hardware.drivers.spads.dashboards.pyqtgraph

.. autoapi-nested-parse::

   SPAD dashboard based on PyQtGraph for real-time visualization.



Module Contents
---------------

Classes
~~~~~~~

.. autoapisummary::

   cc_hardware.drivers.spads.dashboards.pyqtgraph.PyQtGraphDashboardConfig
   cc_hardware.drivers.spads.dashboards.pyqtgraph.DashboardWindow
   cc_hardware.drivers.spads.dashboards.pyqtgraph.PyQtGraphDashboard




.. py:class:: PyQtGraphDashboardConfig


   .. autoapi-inheritance-diagram:: cc_hardware.drivers.spads.dashboards.pyqtgraph.PyQtGraphDashboardConfig
      :parts: 1


   Configuration for the PyQtGraph dashboard.


   .. py:method:: get_instance()

      Get the class instance specified in the configuration.

      :returns: The class instance.



   .. py:method:: create_instance(*args, auto_create = True, **kwargs)

      Create an instance of the class specified in the configuration.

      :attr:`instance` must be set to the fully qualified class name of the class to
      instantiate. If no arguments are provided, the configuration instance will be
      passed as the first argument to the class constructor.

      :Parameters: **\*args** -- Positional arguments to pass to the class constructor

      :keyword auto_create: Whether to automatically create the instance if no arguments
                            are provided
      :keyword \*\*kwargs: Keyword arguments to pass to the class constructor

      :returns: An instance of the specified class.



   .. py:attribute:: config
      :type: Optional[omegaconf.DictConfig]

      The original, uninstantiated config. This is maintained within each nested
      instantiated config to allow for proper serialization and deserialization, as well
      as printing the config as a yaml string.


   .. py:attribute:: custom
      :type: Optional[Dict[str, Any]]

      Custom data to use. This is useful for code-specific logic (i.e. not in yaml
      files) where you want to store data that is not necessarily defined in the config.


   .. py:method:: instantiate(config, *, _convert_ = 'object', **kwargs)
      :classmethod:


      Instantiate the config into an object.

      :Parameters: **config** (*DictConfig | ListConfig*) -- The config to instantiate.

      :keyword _convert_: The conversion method to use. Defaults to "object", meaning
                          all structured configs will be converted to their dataclass equivalent.
      :kwtype _convert_: str
      :keyword \*\*kwargs: Additional keyword arguments to pass to the instantiation method.



   .. py:method:: compose(config_dir, config_name, *, overrides = [], return_hydra_config = False, **kwargs)
      :classmethod:


      Compose a config using the Hydra compose API. This will return the config as
      a HydraContainerConfig instance.

      :Parameters: * **config_dir** (*Path | str*) -- The path to the config directory.
                   * **config_name** (*str*) -- The name of the config file.

      :keyword overrides: The overrides to use when composing the config.
      :kwtype overrides: List[str]
      :keyword return_hydra_config: Whether to return the HydraConfig object.
      :kwtype return_hydra_config: bool
      :keyword \*\*kwargs: Additional keyword arguments to pass to the instantiation method.



   .. py:method:: load(*args, instantiate = True, pattern = None, **instantiate_kwargs)
      :classmethod:


      Wrapper around OmegaConf.load to instantiate the config.

      :keyword instantiate: Whether to instantiate the config into an object.
      :kwtype instantiate: bool
      :keyword pattern: The specific pattern to select from the loaded
                        config.
      :kwtype pattern: Optional[str]
      :keyword \*\*instantiate_kwargs: Additional keyword arguments to pass to the
                                       instantiation method.



   .. py:method:: create(*args, instantiate = True, **instantiate_kwargs)
      :classmethod:


      Wrapper around OmegaConf.create to instantiate the config.

      :keyword instantiate: Whether to instantiate the config into an object.
      :kwtype instantiate: bool
      :keyword \*\*instantiate_kwargs: Additional keyword arguments to pass to the
                                       instantiation method.



   .. py:method:: merge_with(*others)

      Wrapper around OmegaConf.merge to merge the config with another config.

      :Parameters: **others** (*DictConfig | ListConfig | Dict | List*) -- The other config(s) to
                   merge with.



   .. py:method:: copy()

      Wrapper around the copy method to return a new instance of this class.

      .. note::

         This method will perform a deepcopy, meaning the :meth:`__getstate__` and
         :meth:`__setstate__` methods will be called. This is fairly slow since
         the object is pickled and unpickled.



   .. py:method:: save(path, *, header = None)

      Saves the config to a yaml file.

      :Parameters: **path** (*Path | str*) -- The path to save the config to.

      :keyword header: The header to add to the top of the yaml file.
      :kwtype header: str



   .. py:method:: to_yaml()

      Wrapper around OmegaConf.to_yaml to convert the config to a yaml string.
      Adds some custom representers.

      This uses the stored config attribute to convert to yaml. If the config is None,
      this will return the default string representation of the object.



   .. py:method:: __getstate__()

      This is used to pickle the object. We'll return the config as the state.



   .. py:method:: __setstate__(state)

      This is used to unpickle the object. We'll set the config from the state.



   .. py:method:: __str__()

      Convert the config to a yaml string.



   .. py:method:: register(class_type)
                  register(class_name: str, module_path: str) -> None
      :classmethod:


      Register the given class in this registry.

      :Parameters: * **class_type** -- The class to register. Can be a class type or a str defining
                     a class name to be lazily loaded. If the class_type is a type, this
                     method will return the class itself (useful for decorators).
                   * **module_path** -- The module path where the class can be found
                     (e.g. "my_module.my_submodule"). Only used if class_type is a str.
                     This is the full importable path to the class. The final class
                     path will be ``module_path.class_type``.

      :returns: The registered class if class_type is a class type, otherwise None.



   .. py:method:: create_from_registry(name, *args, **kwargs)
      :classmethod:


      Create an instance of a registered class, performing lazy loading if necessary.

      :Parameters: * **name** -- The name of the class to instantiate.
                   * **\*args** -- Positional arguments to pass to the class constructor.
                   * **\*\*kwargs** -- Keyword arguments to pass to the class constructor.

      :returns: An instance of the requested class.

      :raises ValueError: If the class name is not registered.



   .. py:method:: registry()

      Get the registry for this class.

      :returns: A dictionary mapping class names to class objects or lazy load paths.



   .. py:method:: registered()

      Get an enumeration of the registered classes.

      :returns: An enumeration of the registered classes.



.. py:class:: DashboardWindow(parent=None)


   .. autoapi-inheritance-diagram:: cc_hardware.drivers.spads.dashboards.pyqtgraph.DashboardWindow
      :parts: 1


   Custom window class with a fixed settings panel on the right.


   .. py:method:: init_ui(settings)

      Initializes the user interface with a settings panel and plots.



   .. py:method:: keyPressEvent(event)

      Handles key press events to allow exiting the application.



.. py:class:: PyQtGraphDashboard(config, sensor)


   .. autoapi-inheritance-diagram:: cc_hardware.drivers.spads.dashboards.pyqtgraph.PyQtGraphDashboard
      :parts: 1


   Dashboard implementation using PyQtGraph for real-time visualization.


   .. py:property:: config
      :type: PyQtGraphDashboardConfig

      Retrieves the dashboard configuration.


   .. py:method:: setup()

      Sets up the PyQtGraph plot layout and styling.

      :Parameters: **fullscreen** (*bool*) -- Whether to display in fullscreen mode.



   .. py:method:: run()

      Executes the PyQtGraph dashboard application.

      :Parameters: * **fullscreen** (*bool*) -- Whether to display in fullscreen mode.
                   * **headless** (*bool*) -- Whether to run in headless mode.
                   * **save** (*Path | None*) -- If provided, save the output to this file.



   .. py:method:: update(frame, *, histograms = None, step = True)

      Updates the histogram data in the plots.



   .. py:property:: sensor
      :type: cc_hardware.drivers.spads.spad.SPADSensor

      Retrieves the SPAD sensor instance.


   .. py:property:: min_bin
      :type: int

      Minimum bin value for the histogram.

      Supports variable sized bins based on the sensor configuration.


   .. py:property:: max_bin
      :type: int

      Maximum bin value for the histogram.

      Supports variable sized bins based on the sensor configuration.


   .. py:method:: register(class_type)
                  register(class_name: str, module_path: str) -> None
      :classmethod:


      Register the given class in this registry.

      :Parameters: * **class_type** -- The class to register. Can be a class type or a str defining
                     a class name to be lazily loaded. If the class_type is a type, this
                     method will return the class itself (useful for decorators).
                   * **module_path** -- The module path where the class can be found
                     (e.g. "my_module.my_submodule"). Only used if class_type is a str.
                     This is the full importable path to the class. The final class
                     path will be ``module_path.class_type``.

      :returns: The registered class if class_type is a class type, otherwise None.



   .. py:method:: create_from_registry(name, *args, **kwargs)
      :classmethod:


      Create an instance of a registered class, performing lazy loading if necessary.

      :Parameters: * **name** -- The name of the class to instantiate.
                   * **\*args** -- Positional arguments to pass to the class constructor.
                   * **\*\*kwargs** -- Keyword arguments to pass to the class constructor.

      :returns: An instance of the requested class.

      :raises ValueError: If the class name is not registered.



   .. py:method:: registry()

      Get the registry for this class.

      :returns: A dictionary mapping class names to class objects or lazy load paths.



   .. py:method:: registered()

      Get an enumeration of the registered classes.

      :returns: An enumeration of the registered classes.



