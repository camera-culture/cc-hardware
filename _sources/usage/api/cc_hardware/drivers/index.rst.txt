:orphan:


:py:mod:`cc_hardware.drivers`
=============================


.. py:module:: cc_hardware.drivers


Subpackages
-----------
.. toctree::
   :titlesonly:
   :maxdepth: 3

   cameras/index.rst
   mocap/index.rst
   spads/index.rst
   stepper_motors/index.rst


Submodules
----------
.. toctree::
   :titlesonly:
   :maxdepth: 1

   safe_serial/index.rst
   sensor/index.rst


Package Contents
----------------

Classes
~~~~~~~

.. autoapisummary::

   cc_hardware.drivers.Camera
   cc_hardware.drivers.CameraConfig
   cc_hardware.drivers.MotionCaptureSensor
   cc_hardware.drivers.MotionCaptureSensorConfig
   cc_hardware.drivers.SafeSerial
   cc_hardware.drivers.Sensor
   cc_hardware.drivers.SensorConfig
   cc_hardware.drivers.SPADSensor
   cc_hardware.drivers.SPADSensorConfig
   cc_hardware.drivers.DummyStepperMotor
   cc_hardware.drivers.StepperMotor
   cc_hardware.drivers.StepperMotorSystem
   cc_hardware.drivers.StepperMotorSystemAxis




.. py:class:: Camera(config)


   .. autoapi-inheritance-diagram:: cc_hardware.drivers.Camera
      :parts: 1


   Abstract base class for a Camera sensor, extending the Sensor class.
   Defines methods and properties for specific for cameras.


   .. py:method:: accumulate(num_samples = 1, *, average)
      :abstractmethod:


      Accumulate a specified number of samples from the camera.

      :Parameters: **num_samples** (*int*) -- Number of samples to accumulate.

      :keyword average: Whether to average the accumulated samples.
      :kwtype average: bool

      :returns: *np.ndarray* -- The accumulated samples as an array.



   .. py:property:: distortion_coefficients
      :type: numpy.ndarray
      :abstractmethod:

      Get the camera's distortion coefficients.

      :returns: *np.ndarray* -- An array representing the distortion coefficients.


   .. py:property:: intrinsic_matrix
      :type: numpy.ndarray
      :abstractmethod:

      Get the camera's intrinsic matrix.

      :returns: *np.ndarray* -- A 3x3 matrix representing the camera intrinsics.


   .. py:property:: resolution
      :type: tuple[int, int]
      :abstractmethod:

      Get the camera's resolution.

      :returns: *tuple[int, int]* --

                A tuple containing the width and height of
                                 the camera resolution.


   .. py:property:: settings
      :type: dict[str, cc_hardware.utils.setting.Setting]

      Retrieves the sensor settings.


   .. py:method:: update(**kwargs)

      Updates the sensor configuration with provided keyword arguments. If there are
      any changes given via the kwargs or in the settings, the configuration is sent
      to the sensor.

      :Parameters: **\*\*kwargs** -- Configuration parameters to update. Keys must match
                   the fields of SensorConfig.

      :returns: *bool* -- True if the configuration was updated. False if no changes were made.



   .. py:property:: is_okay
      :type: bool
      :abstractmethod:

      Checks if the sensor is operational.


   .. py:method:: close()
      :abstractmethod:


      Closes the sensor and releases any resources.



   .. py:method:: calibrate()
      :abstractmethod:


      Calibrates the sensor.



   .. py:method:: __del__()

      Destructor to ensure the sensor is properly closed.



   .. py:property:: config
      :type: T

      Retrieves the component configuration.


   .. py:method:: create_from_config(config, **kwargs)
      :classmethod:


      Create an instance of the class from a configuration object.

      :Parameters: **config** (*T*) -- The configuration object.

      :returns: *Self* -- An instance of the class.



   .. py:method:: register(class_type)
                  register(class_name: str, module_path: str) -> None
                  register(class_name: str, module_path: str, friend: str) -> None
      :classmethod:


      Registers a class in this registry.

      :Parameters: * **class_type** (*type[Self] | str*) -- A class object or a class name for lazy
                     loading.
                   * **module_path** (*str | None*) -- Path to the module if `class_type` is a string.
                   * **friend** (*str | None*) -- Name of another class to associate with this class.

      :returns: *type[Self] | None* --

                The registered class if `class_type` is a type,
                    otherwise None.



   .. py:method:: create_from_registry(name = None, *args, **kwargs)
      :classmethod:


      Creates an instance of a registered class, performing lazy loading if necessary.

      :Parameters: * **name** (*str | None*) -- The name of the class to instantiate. If None,
                     and only one class is registered, it will instantiate that class.
                   * **\*args** (*Any*) -- Positional arguments to pass to the class constructor.
                   * **\*\*kwargs** (*Any*) -- Keyword arguments to pass to the class constructor.

      :returns: *Self | Any* --

                An instance of the requested class, or an associated
                    'friend' class.



   .. py:method:: registry()

      Get the registry for this class.

      :returns: A dictionary mapping class names to class objects or lazy load paths.



   .. py:method:: registered()

      Get an enumeration of the registered classes.

      :returns: An enumeration of the registered classes.



.. py:class:: CameraConfig


   .. autoapi-inheritance-diagram:: cc_hardware.drivers.CameraConfig
      :parts: 1


   Configuration for Camera sensors.


   .. py:property:: settings
      :type: dict[str, cc_hardware.utils.setting.Setting]

      Retrieves the sensor settings.


   .. py:attribute:: config
      :type: Optional[omegaconf.DictConfig]

      The original, uninstantiated config. This is maintained within each nested
      instantiated config to allow for proper serialization and deserialization, as well
      as printing the config as a yaml string.


   .. py:attribute:: custom
      :type: Optional[Dict[str, Any]]

      Custom data to use. This is useful for code-specific logic (i.e. not in yaml
      files) where you want to store data that is not necessarily defined in the config.


   .. py:method:: instantiate(config, *, _convert_ = 'object', **kwargs)
      :classmethod:


      Instantiate the config into an object.

      :Parameters: **config** (*DictConfig | ListConfig*) -- The config to instantiate.

      :keyword _convert_: The conversion method to use. Defaults to "object", meaning
                          all structured configs will be converted to their dataclass equivalent.
      :kwtype _convert_: str
      :keyword \*\*kwargs: Additional keyword arguments to pass to the instantiation method.



   .. py:method:: compose(config_dir, config_name, *, overrides = [], return_hydra_config = False, **kwargs)
      :classmethod:


      Compose a config using the Hydra compose API. This will return the config as
      a HydraContainerConfig instance.

      :Parameters: * **config_dir** (*Path | str*) -- The path to the config directory.
                   * **config_name** (*str*) -- The name of the config file.

      :keyword overrides: The overrides to use when composing the config.
      :kwtype overrides: List[str]
      :keyword return_hydra_config: Whether to return the HydraConfig object.
      :kwtype return_hydra_config: bool
      :keyword \*\*kwargs: Additional keyword arguments to pass to the instantiation method.



   .. py:method:: load(*args, instantiate = True, pattern = None, **instantiate_kwargs)
      :classmethod:


      Wrapper around OmegaConf.load to instantiate the config.

      :keyword instantiate: Whether to instantiate the config into an object.
      :kwtype instantiate: bool
      :keyword pattern: The specific pattern to select from the loaded
                        config.
      :kwtype pattern: Optional[str]
      :keyword \*\*instantiate_kwargs: Additional keyword arguments to pass to the
                                       instantiation method.



   .. py:method:: create(*args, instantiate = True, instantiate_kwargs = {}, **kwargs)
      :classmethod:


      Wrapper around OmegaConf.create to instantiate the config.

      :keyword instantiate: Whether to instantiate the config into an object.
      :kwtype instantiate: bool
      :keyword \*\*instantiate_kwargs: Additional keyword arguments to pass to the
                                       instantiation method.



   .. py:method:: merge_with(*others)

      Wrapper around OmegaConf.merge to merge the config with another config.

      :Parameters: **others** (*DictConfig | ListConfig | Dict | List*) -- The other config(s) to
                   merge with.



   .. py:method:: copy()

      Wrapper around the copy method to return a new instance of this class.

      .. note::

         This method will perform a deepcopy, meaning the :meth:`__getstate__` and
         :meth:`__setstate__` methods will be called. This is fairly slow since
         the object is pickled and unpickled.



   .. py:method:: save(path, *, header = None)

      Saves the config to a yaml file.

      :Parameters: **path** (*Path | str*) -- The path to save the config to.

      :keyword header: The header to add to the top of the yaml file.
      :kwtype header: str



   .. py:method:: to_yaml()

      Wrapper around OmegaConf.to_yaml to convert the config to a yaml string.
      Adds some custom representers.

      This uses the stored config attribute to convert to yaml. If the config is None,
      this will return the default string representation of the object.



   .. py:method:: __getstate__()

      This is used to pickle the object. We'll return the config as the state.



   .. py:method:: __setstate__(state)

      This is used to unpickle the object. We'll set the config from the state.



   .. py:method:: __str__()

      Convert the config to a yaml string.



   .. py:method:: register(class_type)
                  register(class_name: str, module_path: str) -> None
                  register(class_name: str, module_path: str, friend: str) -> None
      :classmethod:


      Registers a class in this registry.

      :Parameters: * **class_type** (*type[Self] | str*) -- A class object or a class name for lazy
                     loading.
                   * **module_path** (*str | None*) -- Path to the module if `class_type` is a string.
                   * **friend** (*str | None*) -- Name of another class to associate with this class.

      :returns: *type[Self] | None* --

                The registered class if `class_type` is a type,
                    otherwise None.



   .. py:method:: create_from_registry(name = None, *args, **kwargs)
      :classmethod:


      Creates an instance of a registered class, performing lazy loading if necessary.

      :Parameters: * **name** (*str | None*) -- The name of the class to instantiate. If None,
                     and only one class is registered, it will instantiate that class.
                   * **\*args** (*Any*) -- Positional arguments to pass to the class constructor.
                   * **\*\*kwargs** (*Any*) -- Keyword arguments to pass to the class constructor.

      :returns: *Self | Any* --

                An instance of the requested class, or an associated
                    'friend' class.



   .. py:method:: registry()

      Get the registry for this class.

      :returns: A dictionary mapping class names to class objects or lazy load paths.



   .. py:method:: registered()

      Get an enumeration of the registered classes.

      :returns: An enumeration of the registered classes.



.. py:class:: MotionCaptureSensor(config)


   .. autoapi-inheritance-diagram:: cc_hardware.drivers.MotionCaptureSensor
      :parts: 1


   An abstract base class for motion capture sensors.


   .. py:method:: accumulate(num_samples = 1)
      :abstractmethod:


      Accumulates the specified number of pose samples from the sensor.

      :Parameters: **num_samples** (*int*) -- The number of samples to accumulate into the pose.
                   The accumulation method (i.e. summing, averaging) may vary depending on
                   the sensor. Defaults to 1.



   .. py:property:: settings
      :type: dict[str, cc_hardware.utils.setting.Setting]

      Retrieves the sensor settings.


   .. py:method:: update(**kwargs)

      Updates the sensor configuration with provided keyword arguments. If there are
      any changes given via the kwargs or in the settings, the configuration is sent
      to the sensor.

      :Parameters: **\*\*kwargs** -- Configuration parameters to update. Keys must match
                   the fields of SensorConfig.

      :returns: *bool* -- True if the configuration was updated. False if no changes were made.



   .. py:property:: is_okay
      :type: bool
      :abstractmethod:

      Checks if the sensor is operational.


   .. py:method:: close()
      :abstractmethod:


      Closes the sensor and releases any resources.



   .. py:method:: calibrate()
      :abstractmethod:


      Calibrates the sensor.



   .. py:method:: __del__()

      Destructor to ensure the sensor is properly closed.



   .. py:property:: config
      :type: T

      Retrieves the component configuration.


   .. py:method:: create_from_config(config, **kwargs)
      :classmethod:


      Create an instance of the class from a configuration object.

      :Parameters: **config** (*T*) -- The configuration object.

      :returns: *Self* -- An instance of the class.



   .. py:method:: register(class_type)
                  register(class_name: str, module_path: str) -> None
                  register(class_name: str, module_path: str, friend: str) -> None
      :classmethod:


      Registers a class in this registry.

      :Parameters: * **class_type** (*type[Self] | str*) -- A class object or a class name for lazy
                     loading.
                   * **module_path** (*str | None*) -- Path to the module if `class_type` is a string.
                   * **friend** (*str | None*) -- Name of another class to associate with this class.

      :returns: *type[Self] | None* --

                The registered class if `class_type` is a type,
                    otherwise None.



   .. py:method:: create_from_registry(name = None, *args, **kwargs)
      :classmethod:


      Creates an instance of a registered class, performing lazy loading if necessary.

      :Parameters: * **name** (*str | None*) -- The name of the class to instantiate. If None,
                     and only one class is registered, it will instantiate that class.
                   * **\*args** (*Any*) -- Positional arguments to pass to the class constructor.
                   * **\*\*kwargs** (*Any*) -- Keyword arguments to pass to the class constructor.

      :returns: *Self | Any* --

                An instance of the requested class, or an associated
                    'friend' class.



   .. py:method:: registry()

      Get the registry for this class.

      :returns: A dictionary mapping class names to class objects or lazy load paths.



   .. py:method:: registered()

      Get an enumeration of the registered classes.

      :returns: An enumeration of the registered classes.



.. py:class:: MotionCaptureSensorConfig


   .. autoapi-inheritance-diagram:: cc_hardware.drivers.MotionCaptureSensorConfig
      :parts: 1


   Configuration for SPAD sensors.


   .. py:property:: settings
      :type: dict[str, cc_hardware.utils.setting.Setting]

      Retrieves the sensor settings.


   .. py:attribute:: config
      :type: Optional[omegaconf.DictConfig]

      The original, uninstantiated config. This is maintained within each nested
      instantiated config to allow for proper serialization and deserialization, as well
      as printing the config as a yaml string.


   .. py:attribute:: custom
      :type: Optional[Dict[str, Any]]

      Custom data to use. This is useful for code-specific logic (i.e. not in yaml
      files) where you want to store data that is not necessarily defined in the config.


   .. py:method:: instantiate(config, *, _convert_ = 'object', **kwargs)
      :classmethod:


      Instantiate the config into an object.

      :Parameters: **config** (*DictConfig | ListConfig*) -- The config to instantiate.

      :keyword _convert_: The conversion method to use. Defaults to "object", meaning
                          all structured configs will be converted to their dataclass equivalent.
      :kwtype _convert_: str
      :keyword \*\*kwargs: Additional keyword arguments to pass to the instantiation method.



   .. py:method:: compose(config_dir, config_name, *, overrides = [], return_hydra_config = False, **kwargs)
      :classmethod:


      Compose a config using the Hydra compose API. This will return the config as
      a HydraContainerConfig instance.

      :Parameters: * **config_dir** (*Path | str*) -- The path to the config directory.
                   * **config_name** (*str*) -- The name of the config file.

      :keyword overrides: The overrides to use when composing the config.
      :kwtype overrides: List[str]
      :keyword return_hydra_config: Whether to return the HydraConfig object.
      :kwtype return_hydra_config: bool
      :keyword \*\*kwargs: Additional keyword arguments to pass to the instantiation method.



   .. py:method:: load(*args, instantiate = True, pattern = None, **instantiate_kwargs)
      :classmethod:


      Wrapper around OmegaConf.load to instantiate the config.

      :keyword instantiate: Whether to instantiate the config into an object.
      :kwtype instantiate: bool
      :keyword pattern: The specific pattern to select from the loaded
                        config.
      :kwtype pattern: Optional[str]
      :keyword \*\*instantiate_kwargs: Additional keyword arguments to pass to the
                                       instantiation method.



   .. py:method:: create(*args, instantiate = True, instantiate_kwargs = {}, **kwargs)
      :classmethod:


      Wrapper around OmegaConf.create to instantiate the config.

      :keyword instantiate: Whether to instantiate the config into an object.
      :kwtype instantiate: bool
      :keyword \*\*instantiate_kwargs: Additional keyword arguments to pass to the
                                       instantiation method.



   .. py:method:: merge_with(*others)

      Wrapper around OmegaConf.merge to merge the config with another config.

      :Parameters: **others** (*DictConfig | ListConfig | Dict | List*) -- The other config(s) to
                   merge with.



   .. py:method:: copy()

      Wrapper around the copy method to return a new instance of this class.

      .. note::

         This method will perform a deepcopy, meaning the :meth:`__getstate__` and
         :meth:`__setstate__` methods will be called. This is fairly slow since
         the object is pickled and unpickled.



   .. py:method:: save(path, *, header = None)

      Saves the config to a yaml file.

      :Parameters: **path** (*Path | str*) -- The path to save the config to.

      :keyword header: The header to add to the top of the yaml file.
      :kwtype header: str



   .. py:method:: to_yaml()

      Wrapper around OmegaConf.to_yaml to convert the config to a yaml string.
      Adds some custom representers.

      This uses the stored config attribute to convert to yaml. If the config is None,
      this will return the default string representation of the object.



   .. py:method:: __getstate__()

      This is used to pickle the object. We'll return the config as the state.



   .. py:method:: __setstate__(state)

      This is used to unpickle the object. We'll set the config from the state.



   .. py:method:: __str__()

      Convert the config to a yaml string.



   .. py:method:: register(class_type)
                  register(class_name: str, module_path: str) -> None
                  register(class_name: str, module_path: str, friend: str) -> None
      :classmethod:


      Registers a class in this registry.

      :Parameters: * **class_type** (*type[Self] | str*) -- A class object or a class name for lazy
                     loading.
                   * **module_path** (*str | None*) -- Path to the module if `class_type` is a string.
                   * **friend** (*str | None*) -- Name of another class to associate with this class.

      :returns: *type[Self] | None* --

                The registered class if `class_type` is a type,
                    otherwise None.



   .. py:method:: create_from_registry(name = None, *args, **kwargs)
      :classmethod:


      Creates an instance of a registered class, performing lazy loading if necessary.

      :Parameters: * **name** (*str | None*) -- The name of the class to instantiate. If None,
                     and only one class is registered, it will instantiate that class.
                   * **\*args** (*Any*) -- Positional arguments to pass to the class constructor.
                   * **\*\*kwargs** (*Any*) -- Keyword arguments to pass to the class constructor.

      :returns: *Self | Any* --

                An instance of the requested class, or an associated
                    'friend' class.



   .. py:method:: registry()

      Get the registry for this class.

      :returns: A dictionary mapping class names to class objects or lazy load paths.



   .. py:method:: registered()

      Get an enumeration of the registered classes.

      :returns: An enumeration of the registered classes.



.. py:class:: SafeSerial(*args, lock_type = 'multiprocessing', **kwargs)

   A thread-safe implementation of the serial.Serial class that synchronizes read and
   write operations using a lock. Provides additional utility methods for creating
   instances and handling data writes in different formats.

   :keyword lock_type: The type of lock to use. Defaults to "multiprocessing". Can be
                       "threading", "multiprocessing", or "none".
   :kwtype lock_type: str


   .. py:method:: create(port = None, *, wait = 1, one = False, **kwargs)
      :classmethod:


      Create an instance of SafeSerial from a serial port. Checks all available ports
      if no port is specified and waits for the serial device to reset before
      establishing the connection.

      :Parameters: * **port** (*str | None*) -- The specific serial port to connect to, or None to
                     check all available ports.
                   * **wait** (*int*) -- The number of seconds to wait for the device to reset. Default
                     is 2 seconds.
                   * **one** (*bool*) -- Whether to force the method to return a single instance. If
                     True and multiple instances are found, an error is raised. Default is
                     False.
                   * **\*\*kwargs** -- Additional keyword arguments passed to the SafeSerial constructor.

      :returns: *SafeSerial | list[SafeSerial]* --

                A single instance if a port is specified
                    or multiple instances if no port is specified.



   .. py:method:: write(data)

      Write data to the serial port. If the data type is invalid, a warning is logged.

      :Parameters: **data** (*Any*) -- The data to write to the serial port.

      :returns: None



   .. py:method:: read(size = 1)

      Read a specified number of bytes from the serial port.

      :Parameters: **size** (*int*) -- The number of bytes to read. Default is 1.

      :returns: *bytes* -- The bytes read from the serial port.



   .. py:method:: wait_for_start_talk(timeout = None)

      Wait until SafeSerial starts talking. Returns data if successful,
      None if timeout.

      :Parameters: **timeout** (*float | None*) -- Maximum time to wait before giving up. Defaults to
                   None.

      :returns: *bytes | None* --

                The received data if SafeSerial starts talking, otherwise
                    None.



   .. py:method:: wait_for_stop_talk(timeout = None)

      Wait until SafeSerial stops talking. Returns accumulated data if stopped before
          timeout.

      :Parameters: **timeout** (*float | None*) -- Maximum time to wait before giving up. Defaults to
                   None.

      :returns: *bytes | None* --

                The accumulated data if SafeSerial stops talking, otherwise
                    None.



   .. py:method:: write_and_wait_for_start_talk(data, timeout = None, tries = 10)

      Write data to SafeSerial and wait for it to start talking with timeout.
      If timeout happens before something is received, resend data.

      :Parameters: * **data** (*str*) -- The data to be written.
                   * **timeout** (*float | None*) -- The maximum wait time for each attempt. Defaults to
                     instance timeout.
                   * **tries** (*int*) -- The number of attempts to perform. Defaults to 10.

      :returns: *bool* -- True if successful, False otherwise.



   .. py:method:: write_and_wait_for_stop_talk(data, timeout = None, tries = 10, return_data = False)

      Write data to SafeSerial and wait for it to stop talking with timeout.
      If timeout happens before something is received, resend data.

      :Parameters: * **data** (*str*) -- The data to be written.
                   * **timeout** (*float | None*) -- The maximum wait time for each attempt. Defaults to
                     instance timeout.
                   * **tries** (*int*) -- The number of attempts to perform. Defaults to 10.
                   * **return_data** (*bool*) -- Whether to return the accumulated data upon success.
                     Defaults to False.

      :returns: *bool | tuple[bool, bytes | None]* --

                True if successful, otherwise False.
                    If return_data is True, returns a tuple of success status and
                    accumulated data.



   .. py:method:: write_and_wait_for_start_and_stop_talk(data, timeout = None, tries = 10)

      Write data to SafeSerial and wait for it to start and stop talking with timeout.
      If timeout happens before either event, resend data.

      :Parameters: * **data** (*str*) -- The data to be written.
                   * **timeout** (*float | None*) -- The maximum wait time for each attempt. Defaults to
                     instance timeout.
                   * **tries** (*int*) -- The number of attempts to perform. Defaults to 10.

      :returns: *bool* -- True if successful, False otherwise.



   .. py:method:: __getattr__(name)

      Forward attribute access to the parent serial.Serial class.

      Applies the lock to prevent concurrent access to the serial port.

      :Parameters: **name** (*str*) -- The attribute name to access.

      :returns: *Any* -- The attribute value.



.. py:class:: Sensor(config)


   .. autoapi-inheritance-diagram:: cc_hardware.drivers.Sensor
      :parts: 1


   Abstract base class for sensors.

   :Parameters: **config** (*SensorConfig*) -- The sensor configuration.


   .. py:property:: settings
      :type: dict[str, cc_hardware.utils.setting.Setting]

      Retrieves the sensor settings.


   .. py:method:: update(**kwargs)

      Updates the sensor configuration with provided keyword arguments. If there are
      any changes given via the kwargs or in the settings, the configuration is sent
      to the sensor.

      :Parameters: **\*\*kwargs** -- Configuration parameters to update. Keys must match
                   the fields of SensorConfig.

      :returns: *bool* -- True if the configuration was updated. False if no changes were made.



   .. py:property:: is_okay
      :type: bool
      :abstractmethod:

      Checks if the sensor is operational.


   .. py:method:: close()
      :abstractmethod:


      Closes the sensor and releases any resources.



   .. py:method:: calibrate()
      :abstractmethod:


      Calibrates the sensor.



   .. py:method:: __del__()

      Destructor to ensure the sensor is properly closed.



   .. py:property:: config
      :type: T

      Retrieves the component configuration.


   .. py:method:: create_from_config(config, **kwargs)
      :classmethod:


      Create an instance of the class from a configuration object.

      :Parameters: **config** (*T*) -- The configuration object.

      :returns: *Self* -- An instance of the class.



   .. py:method:: register(class_type)
                  register(class_name: str, module_path: str) -> None
                  register(class_name: str, module_path: str, friend: str) -> None
      :classmethod:


      Registers a class in this registry.

      :Parameters: * **class_type** (*type[Self] | str*) -- A class object or a class name for lazy
                     loading.
                   * **module_path** (*str | None*) -- Path to the module if `class_type` is a string.
                   * **friend** (*str | None*) -- Name of another class to associate with this class.

      :returns: *type[Self] | None* --

                The registered class if `class_type` is a type,
                    otherwise None.



   .. py:method:: create_from_registry(name = None, *args, **kwargs)
      :classmethod:


      Creates an instance of a registered class, performing lazy loading if necessary.

      :Parameters: * **name** (*str | None*) -- The name of the class to instantiate. If None,
                     and only one class is registered, it will instantiate that class.
                   * **\*args** (*Any*) -- Positional arguments to pass to the class constructor.
                   * **\*\*kwargs** (*Any*) -- Keyword arguments to pass to the class constructor.

      :returns: *Self | Any* --

                An instance of the requested class, or an associated
                    'friend' class.



   .. py:method:: registry()

      Get the registry for this class.

      :returns: A dictionary mapping class names to class objects or lazy load paths.



   .. py:method:: registered()

      Get an enumeration of the registered classes.

      :returns: An enumeration of the registered classes.



.. py:class:: SensorConfig


   .. autoapi-inheritance-diagram:: cc_hardware.drivers.SensorConfig
      :parts: 1


   Configuration for sensors.

   When defining a new sensor, create a subclass of this configuration class
   and add any necessary parameters.

   :ivar instance: The sensor instance name. Used to instantiate the sensor from
                   the configuration.

   :vartype instance: str


   .. py:property:: settings
      :type: dict[str, cc_hardware.utils.setting.Setting]

      Retrieves the sensor settings.


   .. py:attribute:: config
      :type: Optional[omegaconf.DictConfig]

      The original, uninstantiated config. This is maintained within each nested
      instantiated config to allow for proper serialization and deserialization, as well
      as printing the config as a yaml string.


   .. py:attribute:: custom
      :type: Optional[Dict[str, Any]]

      Custom data to use. This is useful for code-specific logic (i.e. not in yaml
      files) where you want to store data that is not necessarily defined in the config.


   .. py:method:: instantiate(config, *, _convert_ = 'object', **kwargs)
      :classmethod:


      Instantiate the config into an object.

      :Parameters: **config** (*DictConfig | ListConfig*) -- The config to instantiate.

      :keyword _convert_: The conversion method to use. Defaults to "object", meaning
                          all structured configs will be converted to their dataclass equivalent.
      :kwtype _convert_: str
      :keyword \*\*kwargs: Additional keyword arguments to pass to the instantiation method.



   .. py:method:: compose(config_dir, config_name, *, overrides = [], return_hydra_config = False, **kwargs)
      :classmethod:


      Compose a config using the Hydra compose API. This will return the config as
      a HydraContainerConfig instance.

      :Parameters: * **config_dir** (*Path | str*) -- The path to the config directory.
                   * **config_name** (*str*) -- The name of the config file.

      :keyword overrides: The overrides to use when composing the config.
      :kwtype overrides: List[str]
      :keyword return_hydra_config: Whether to return the HydraConfig object.
      :kwtype return_hydra_config: bool
      :keyword \*\*kwargs: Additional keyword arguments to pass to the instantiation method.



   .. py:method:: load(*args, instantiate = True, pattern = None, **instantiate_kwargs)
      :classmethod:


      Wrapper around OmegaConf.load to instantiate the config.

      :keyword instantiate: Whether to instantiate the config into an object.
      :kwtype instantiate: bool
      :keyword pattern: The specific pattern to select from the loaded
                        config.
      :kwtype pattern: Optional[str]
      :keyword \*\*instantiate_kwargs: Additional keyword arguments to pass to the
                                       instantiation method.



   .. py:method:: create(*args, instantiate = True, instantiate_kwargs = {}, **kwargs)
      :classmethod:


      Wrapper around OmegaConf.create to instantiate the config.

      :keyword instantiate: Whether to instantiate the config into an object.
      :kwtype instantiate: bool
      :keyword \*\*instantiate_kwargs: Additional keyword arguments to pass to the
                                       instantiation method.



   .. py:method:: merge_with(*others)

      Wrapper around OmegaConf.merge to merge the config with another config.

      :Parameters: **others** (*DictConfig | ListConfig | Dict | List*) -- The other config(s) to
                   merge with.



   .. py:method:: copy()

      Wrapper around the copy method to return a new instance of this class.

      .. note::

         This method will perform a deepcopy, meaning the :meth:`__getstate__` and
         :meth:`__setstate__` methods will be called. This is fairly slow since
         the object is pickled and unpickled.



   .. py:method:: save(path, *, header = None)

      Saves the config to a yaml file.

      :Parameters: **path** (*Path | str*) -- The path to save the config to.

      :keyword header: The header to add to the top of the yaml file.
      :kwtype header: str



   .. py:method:: to_yaml()

      Wrapper around OmegaConf.to_yaml to convert the config to a yaml string.
      Adds some custom representers.

      This uses the stored config attribute to convert to yaml. If the config is None,
      this will return the default string representation of the object.



   .. py:method:: __getstate__()

      This is used to pickle the object. We'll return the config as the state.



   .. py:method:: __setstate__(state)

      This is used to unpickle the object. We'll set the config from the state.



   .. py:method:: __str__()

      Convert the config to a yaml string.



   .. py:method:: register(class_type)
                  register(class_name: str, module_path: str) -> None
                  register(class_name: str, module_path: str, friend: str) -> None
      :classmethod:


      Registers a class in this registry.

      :Parameters: * **class_type** (*type[Self] | str*) -- A class object or a class name for lazy
                     loading.
                   * **module_path** (*str | None*) -- Path to the module if `class_type` is a string.
                   * **friend** (*str | None*) -- Name of another class to associate with this class.

      :returns: *type[Self] | None* --

                The registered class if `class_type` is a type,
                    otherwise None.



   .. py:method:: create_from_registry(name = None, *args, **kwargs)
      :classmethod:


      Creates an instance of a registered class, performing lazy loading if necessary.

      :Parameters: * **name** (*str | None*) -- The name of the class to instantiate. If None,
                     and only one class is registered, it will instantiate that class.
                   * **\*args** (*Any*) -- Positional arguments to pass to the class constructor.
                   * **\*\*kwargs** (*Any*) -- Keyword arguments to pass to the class constructor.

      :returns: *Self | Any* --

                An instance of the requested class, or an associated
                    'friend' class.



   .. py:method:: registry()

      Get the registry for this class.

      :returns: A dictionary mapping class names to class objects or lazy load paths.



   .. py:method:: registered()

      Get an enumeration of the registered classes.

      :returns: An enumeration of the registered classes.



.. py:class:: SPADSensor(config)


   .. autoapi-inheritance-diagram:: cc_hardware.drivers.SPADSensor
      :parts: 1


   An abstract base class for Single-Photon Avalanche Diode (SPAD) sensors, designed
   to manage histogram-based measurements. This class defines methods and properties
   related to collecting and analyzing histogram data.

   Inherits:
       Sensor: The base class for all sensors in the system.


   .. py:method:: accumulate(num_samples = 1)
      :abstractmethod:


      Accumulates the specified number of histogram samples from the sensor.

      :Parameters: **num_samples** (*int*) -- The number of samples to accumulate into the histogram.
                   The accumulation method (i.e. summing, averaging) may vary depending on
                   the sensor. Defaults to 1.



   .. py:property:: num_bins
      :type: int
      :abstractmethod:

      Returns the number of bins in the sensor's histogram. This indicates the
      number of discrete values or ranges that the sensor can measure. The total
      distance a sensor can measure is equal to the number of bins multiplied by
      the bin width.

      :returns: *int* -- The total number of bins in the histogram.


   .. py:property:: resolution
      :type: tuple[int, int]
      :abstractmethod:

      Returns the resolution of the sensor as a tuple (width, height). This indicates
      the spatial resolution of the sensor, where the width and height refer to the
      number of pixels or sampling points in the respective dimensions.

      :returns: *tuple[int, int]* --

                A tuple representing the sensor's resolution
                    (width, height).


   .. py:property:: settings
      :type: dict[str, cc_hardware.utils.setting.Setting]

      Retrieves the sensor settings.


   .. py:method:: update(**kwargs)

      Updates the sensor configuration with provided keyword arguments. If there are
      any changes given via the kwargs or in the settings, the configuration is sent
      to the sensor.

      :Parameters: **\*\*kwargs** -- Configuration parameters to update. Keys must match
                   the fields of SensorConfig.

      :returns: *bool* -- True if the configuration was updated. False if no changes were made.



   .. py:property:: is_okay
      :type: bool
      :abstractmethod:

      Checks if the sensor is operational.


   .. py:method:: close()
      :abstractmethod:


      Closes the sensor and releases any resources.



   .. py:method:: calibrate()
      :abstractmethod:


      Calibrates the sensor.



   .. py:method:: __del__()

      Destructor to ensure the sensor is properly closed.



   .. py:property:: config
      :type: T

      Retrieves the component configuration.


   .. py:method:: create_from_config(config, **kwargs)
      :classmethod:


      Create an instance of the class from a configuration object.

      :Parameters: **config** (*T*) -- The configuration object.

      :returns: *Self* -- An instance of the class.



   .. py:method:: register(class_type)
                  register(class_name: str, module_path: str) -> None
                  register(class_name: str, module_path: str, friend: str) -> None
      :classmethod:


      Registers a class in this registry.

      :Parameters: * **class_type** (*type[Self] | str*) -- A class object or a class name for lazy
                     loading.
                   * **module_path** (*str | None*) -- Path to the module if `class_type` is a string.
                   * **friend** (*str | None*) -- Name of another class to associate with this class.

      :returns: *type[Self] | None* --

                The registered class if `class_type` is a type,
                    otherwise None.



   .. py:method:: create_from_registry(name = None, *args, **kwargs)
      :classmethod:


      Creates an instance of a registered class, performing lazy loading if necessary.

      :Parameters: * **name** (*str | None*) -- The name of the class to instantiate. If None,
                     and only one class is registered, it will instantiate that class.
                   * **\*args** (*Any*) -- Positional arguments to pass to the class constructor.
                   * **\*\*kwargs** (*Any*) -- Keyword arguments to pass to the class constructor.

      :returns: *Self | Any* --

                An instance of the requested class, or an associated
                    'friend' class.



   .. py:method:: registry()

      Get the registry for this class.

      :returns: A dictionary mapping class names to class objects or lazy load paths.



   .. py:method:: registered()

      Get an enumeration of the registered classes.

      :returns: An enumeration of the registered classes.



.. py:class:: SPADSensorConfig


   .. autoapi-inheritance-diagram:: cc_hardware.drivers.SPADSensorConfig
      :parts: 1


   Configuration for SPAD sensors.


   .. py:property:: settings
      :type: dict[str, cc_hardware.utils.setting.Setting]

      Retrieves the sensor settings.


   .. py:attribute:: config
      :type: Optional[omegaconf.DictConfig]

      The original, uninstantiated config. This is maintained within each nested
      instantiated config to allow for proper serialization and deserialization, as well
      as printing the config as a yaml string.


   .. py:attribute:: custom
      :type: Optional[Dict[str, Any]]

      Custom data to use. This is useful for code-specific logic (i.e. not in yaml
      files) where you want to store data that is not necessarily defined in the config.


   .. py:method:: instantiate(config, *, _convert_ = 'object', **kwargs)
      :classmethod:


      Instantiate the config into an object.

      :Parameters: **config** (*DictConfig | ListConfig*) -- The config to instantiate.

      :keyword _convert_: The conversion method to use. Defaults to "object", meaning
                          all structured configs will be converted to their dataclass equivalent.
      :kwtype _convert_: str
      :keyword \*\*kwargs: Additional keyword arguments to pass to the instantiation method.



   .. py:method:: compose(config_dir, config_name, *, overrides = [], return_hydra_config = False, **kwargs)
      :classmethod:


      Compose a config using the Hydra compose API. This will return the config as
      a HydraContainerConfig instance.

      :Parameters: * **config_dir** (*Path | str*) -- The path to the config directory.
                   * **config_name** (*str*) -- The name of the config file.

      :keyword overrides: The overrides to use when composing the config.
      :kwtype overrides: List[str]
      :keyword return_hydra_config: Whether to return the HydraConfig object.
      :kwtype return_hydra_config: bool
      :keyword \*\*kwargs: Additional keyword arguments to pass to the instantiation method.



   .. py:method:: load(*args, instantiate = True, pattern = None, **instantiate_kwargs)
      :classmethod:


      Wrapper around OmegaConf.load to instantiate the config.

      :keyword instantiate: Whether to instantiate the config into an object.
      :kwtype instantiate: bool
      :keyword pattern: The specific pattern to select from the loaded
                        config.
      :kwtype pattern: Optional[str]
      :keyword \*\*instantiate_kwargs: Additional keyword arguments to pass to the
                                       instantiation method.



   .. py:method:: create(*args, instantiate = True, instantiate_kwargs = {}, **kwargs)
      :classmethod:


      Wrapper around OmegaConf.create to instantiate the config.

      :keyword instantiate: Whether to instantiate the config into an object.
      :kwtype instantiate: bool
      :keyword \*\*instantiate_kwargs: Additional keyword arguments to pass to the
                                       instantiation method.



   .. py:method:: merge_with(*others)

      Wrapper around OmegaConf.merge to merge the config with another config.

      :Parameters: **others** (*DictConfig | ListConfig | Dict | List*) -- The other config(s) to
                   merge with.



   .. py:method:: copy()

      Wrapper around the copy method to return a new instance of this class.

      .. note::

         This method will perform a deepcopy, meaning the :meth:`__getstate__` and
         :meth:`__setstate__` methods will be called. This is fairly slow since
         the object is pickled and unpickled.



   .. py:method:: save(path, *, header = None)

      Saves the config to a yaml file.

      :Parameters: **path** (*Path | str*) -- The path to save the config to.

      :keyword header: The header to add to the top of the yaml file.
      :kwtype header: str



   .. py:method:: to_yaml()

      Wrapper around OmegaConf.to_yaml to convert the config to a yaml string.
      Adds some custom representers.

      This uses the stored config attribute to convert to yaml. If the config is None,
      this will return the default string representation of the object.



   .. py:method:: __getstate__()

      This is used to pickle the object. We'll return the config as the state.



   .. py:method:: __setstate__(state)

      This is used to unpickle the object. We'll set the config from the state.



   .. py:method:: __str__()

      Convert the config to a yaml string.



   .. py:method:: register(class_type)
                  register(class_name: str, module_path: str) -> None
                  register(class_name: str, module_path: str, friend: str) -> None
      :classmethod:


      Registers a class in this registry.

      :Parameters: * **class_type** (*type[Self] | str*) -- A class object or a class name for lazy
                     loading.
                   * **module_path** (*str | None*) -- Path to the module if `class_type` is a string.
                   * **friend** (*str | None*) -- Name of another class to associate with this class.

      :returns: *type[Self] | None* --

                The registered class if `class_type` is a type,
                    otherwise None.



   .. py:method:: create_from_registry(name = None, *args, **kwargs)
      :classmethod:


      Creates an instance of a registered class, performing lazy loading if necessary.

      :Parameters: * **name** (*str | None*) -- The name of the class to instantiate. If None,
                     and only one class is registered, it will instantiate that class.
                   * **\*args** (*Any*) -- Positional arguments to pass to the class constructor.
                   * **\*\*kwargs** (*Any*) -- Keyword arguments to pass to the class constructor.

      :returns: *Self | Any* --

                An instance of the requested class, or an associated
                    'friend' class.



   .. py:method:: registry()

      Get the registry for this class.

      :returns: A dictionary mapping class names to class objects or lazy load paths.



   .. py:method:: registered()

      Get an enumeration of the registered classes.

      :returns: An enumeration of the registered classes.



.. py:class:: DummyStepperMotor(*args, **kwargs)

   This is a dummy stepper motor class that does nothing. This is useful for testing
   or when you don't have the stepper connected to the computer. Also can be used for
   axes which don't have a motor attached to them.


.. py:class:: StepperMotor


   .. autoapi-inheritance-diagram:: cc_hardware.drivers.StepperMotor
      :parts: 1


   An abstract base class for controlling a stepper motor. This class provides a
   unified interface for common operations such as moving to a specific position,
   homing, and closing the motor. It also includes a property to check the operational
   status of the motor.

   Any subclass must implement all the defined abstract methods to ensure
   compatibility with the expected motor control behavior.


   .. py:method:: close()
      :abstractmethod:


      Closes the connection or shuts down the stepper motor safely. Implementations
      should ensure that the motor is properly powered down and any resources are
      released to avoid damage or memory leaks.



   .. py:method:: home()
      :abstractmethod:


      Homes the stepper motor to its reference or zero position. This method should
      move the motor to a predefined starting point, which could involve moving
      until a limit switch or sensor is triggered to establish a known starting
      position.



   .. py:method:: move_to(position)
      :abstractmethod:


      Moves the stepper motor to a specific absolute position.

      :Parameters: **position** (*float*) -- The target absolute position to move the motor to. The
                   interpretation of this value may depend on the specific implementation
                   and motor characteristics (e.g., steps, angle).



   .. py:method:: move_by(relative_position)
      :abstractmethod:


      Moves the stepper motor by a specified relative amount from its current
      position.

      :Parameters: **relative_position** (*float*) -- The amount to move the motor by, relative to its
                   current position. This could represent steps, degrees, or any other
                   unit, depending on the motor's configuration.



   .. py:method:: wait_for_move()
      :abstractmethod:


      Waits for the motor to complete its current move operation. This method should
      block the execution until the motor has reached its target position or
      completed the current motion command.



   .. py:property:: position
      :type: float
      :abstractmethod:

      Returns the current position of the stepper motor. The position value should
      represent the motor's current location in the same units as the move_to and
      move_by methods.

      :returns: *float* -- The current position of the motor.


   .. py:property:: is_okay
      :type: bool
      :abstractmethod:

      Checks if the stepper motor is in a healthy operational state. This could
      involve verifying that the motor is not in an error state, is receiving power,
      and has no detected hardware issues.

      :returns: *bool* -- True if the motor is operational, False otherwise.


   .. py:method:: register(class_type)
                  register(class_name: str, module_path: str) -> None
                  register(class_name: str, module_path: str, friend: str) -> None
      :classmethod:


      Registers a class in this registry.

      :Parameters: * **class_type** (*type[Self] | str*) -- A class object or a class name for lazy
                     loading.
                   * **module_path** (*str | None*) -- Path to the module if `class_type` is a string.
                   * **friend** (*str | None*) -- Name of another class to associate with this class.

      :returns: *type[Self] | None* --

                The registered class if `class_type` is a type,
                    otherwise None.



   .. py:method:: create_from_registry(name = None, *args, **kwargs)
      :classmethod:


      Creates an instance of a registered class, performing lazy loading if necessary.

      :Parameters: * **name** (*str | None*) -- The name of the class to instantiate. If None,
                     and only one class is registered, it will instantiate that class.
                   * **\*args** (*Any*) -- Positional arguments to pass to the class constructor.
                   * **\*\*kwargs** (*Any*) -- Keyword arguments to pass to the class constructor.

      :returns: *Self | Any* --

                An instance of the requested class, or an associated
                    'friend' class.



   .. py:method:: registry()

      Get the registry for this class.

      :returns: A dictionary mapping class names to class objects or lazy load paths.



   .. py:method:: registered()

      Get an enumeration of the registered classes.

      :returns: An enumeration of the registered classes.



.. py:class:: StepperMotorSystem(axes)


   .. autoapi-inheritance-diagram:: cc_hardware.drivers.StepperMotorSystem
      :parts: 1


   This is a wrapper around multiple stepper motors which defines the system
   as a whole (i.e. a gantry or multi-axis rotation stage).

   :Parameters: **axes** (*dict[StepperMotorSystemAxis, list[StepperMotor]]*) -- A dictionary of axes
                and the motors that are attached to them.


   .. py:method:: move_to(*positions)
                  move_to(**positions: float)

      Move to the specified position using positional or keyword arguments.



   .. py:method:: move_by(*positions)
                  move_by(**positions: float)

      Moves the steppers to the specified positions.



   .. py:method:: __getattr__(name)

      This is a passthrough to the underlying motor objects.



.. py:class:: StepperMotorSystemAxis(*args, **kwds)


   .. autoapi-inheritance-diagram:: cc_hardware.drivers.StepperMotorSystemAxis
      :parts: 1


   Create a collection of name/value pairs.

   Example enumeration:

   >>> class Color(Enum):
   ...     RED = 1
   ...     BLUE = 2
   ...     GREEN = 3

   Access them by:

   - attribute access:

     >>> Color.RED
     <Color.RED: 1>

   - value lookup:

     >>> Color(1)
     <Color.RED: 1>

   - name lookup:

     >>> Color['RED']
     <Color.RED: 1>

   Enumerations can be iterated over, and know how many members they have:

   >>> len(Color)
   3

   >>> list(Color)
   [<Color.RED: 1>, <Color.BLUE: 2>, <Color.GREEN: 3>]

   Methods can be added to enumerations, and members can have their own
   attributes -- see the documentation for details.


   .. py:method:: __repr__()

      Return repr(self).



   .. py:method:: __str__()

      Return str(self).



   .. py:method:: __dir__()

      Returns public methods and other interesting attributes.



   .. py:method:: __format__(format_spec)

      Default object formatter.

      Return str(self) if format_spec is empty. Raise TypeError otherwise.



   .. py:method:: __hash__()

      Return hash(self).



   .. py:method:: __reduce_ex__(proto)

      Helper for pickle.



   .. py:method:: name()

      The name of the Enum member.



   .. py:method:: value()

      The value of the Enum member.



